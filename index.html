<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hard Platformer</title>
<style>
body {
  margin: 0;
  background: black;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
canvas {
  background: #111;
  border: 2px solid #555;
}
</style>
</head>
<body>

<canvas id="game" width="800" height="400"></canvas>

<script>
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const gravity = 0.7;
const jumpCut = 0.4;
const keys = {};

let deaths = 0;
let startTime = performance.now();
let shake = 0;
let spawnGrace = 15;

let currentRun = [];
let bestGhost = JSON.parse(localStorage.getItem("bestGhost")) || null;
let bestTime = Number(localStorage.getItem("bestTime")) || null;

const player = {
  x: 50, y: 300, w: 30, h: 30,
  vx: 0, vy: 0,
  speed: 0.6,
  maxSpeed: 4,
  jump: -13,
  grounded: false,
  wall: false,
  coyote: 0,
  buffer: 0,
  facing: 1,
  dashSpeed: 9,
  dashTime: 0,
  dashCooldown: 0
};

const level = {
  platforms: [
    { x: 0, y: 360, w: 800, h: 40 }
  ],
  moving: [
    { x: 220, y: 260, w: 120, h: 20, dx: 1.2, range: 160, startX: 220 }
  ],
  spikes: [
    { x: 0, y: 380, w: 800, h: 20 }
  ],
  goal: { x: 720, y: 80, w: 40, h: 40 }
};

function rect(a, b) {
  return a.x < b.x + b.w && a.x + a.w > b.x &&
         a.y < b.y + b.h && a.y + a.h > b.y;
}

document.addEventListener("keydown", e => {
  keys[e.code] = true;
  if (e.code === "KeyR") resetRun();
});
document.addEventListener("keyup", e => keys[e.code] = false);

function resetRun() {
  deaths++;
  shake = 10;
  player.x = 50;
  player.y = 300;
  player.vx = 0;
  player.vy = 0;
  startTime = performance.now();
  currentRun = [];
  spawnGrace = 15;
}

function updateMoving() {
  level.moving.forEach(p => {
    p.x += p.dx;
    if (Math.abs(p.x - p.startX) > p.range) p.dx *= -1;
  });
}

function update() {
  if (spawnGrace > 0) spawnGrace--;

  // INPUT
  if (keys.KeyA) { player.vx -= player.speed; player.facing = -1; }
  if (keys.KeyD) { player.vx += player.speed; player.facing = 1; }

  player.vx *= 0.9;
  player.vx = Math.max(-player.maxSpeed, Math.min(player.maxSpeed, player.vx));

  if (keys.KeyW) player.buffer = 6;
  else player.buffer--;

  // DASH (ground or wall only)
  if (
    (keys.ShiftLeft || keys.ShiftRight) &&
    player.dashCooldown <= 0 &&
    (player.grounded || player.wall)
  ) {
    player.dashTime = 8;
    player.dashCooldown = 25;
  }

  // PHYSICS
  if (player.dashTime > 0) {
    player.vy = 0;
    player.vx = player.facing * player.dashSpeed;
    player.dashTime--;
  } else {
    player.vy += gravity;
    player.dashCooldown--;
  }

  player.x += player.vx;
  player.y += player.vy;

  player.grounded = false;
  player.wall = false;

  [...level.platforms, ...level.moving].forEach(p => {
    if (rect(player, p)) {
      const prevX = player.x - player.vx;
      const prevY = player.y - player.vy;

      if (prevY + player.h <= p.y) {
        player.y = p.y - player.h;
        player.vy = 0;
        player.grounded = true;
        player.coyote = 6;
        if (p.dx) player.x += p.dx;
      } else if (prevX + player.w <= p.x) {
        player.x = p.x - player.w;
        player.wall = true;
      } else if (prevX >= p.x + p.w) {
        player.x = p.x + p.w;
        player.wall = true;
      }
    }
  });

  if (!player.grounded) player.coyote--;

  // JUMP
  if (player.buffer > 0) {
    if (player.coyote > 0) {
      player.vy = player.jump;
      player.buffer = 0;
    } else if (player.wall) {
      player.vy = player.jump;
      player.vx = -player.facing * 6;
      player.buffer = 0;
    }
  }

  // VARIABLE JUMP
  if (!keys.KeyW && player.vy < 0) {
    player.vy *= jumpCut;
  }

  // DEATH (fully enabled)
  if (spawnGrace <= 0) {
    level.spikes.forEach(s => {
      if (rect(player, s)) resetRun();
    });
  }

  if (player.y > canvas.height) resetRun();

  currentRun.push({ x: player.x, y: player.y });

  // GOAL (reachable jump path is guaranteed)
  if (rect(player, level.goal)) {
    const time = ((performance.now() - startTime) / 1000).toFixed(2);
    if (!bestTime || time < bestTime) {
      bestTime = time;
      bestGhost = [...currentRun];
      localStorage.setItem("bestTime", bestTime);
      localStorage.setItem("bestGhost", JSON.stringify(bestGhost));
    }
    alert(`FINISH!\nTime: ${time}s\nDeaths: ${deaths}`);
    resetRun();
  }

  updateMoving();
}

function draw() {
  ctx.save();
  if (shake) {
    ctx.translate((Math.random() - 0.5) * shake, (Math.random() - 0.5) * shake);
    shake--;
  }

  ctx.clearRect(0, 0, 800, 400);

  // GHOST
  if (bestGhost) {
    const i = currentRun.length;
    if (bestGhost[i]) {
      ctx.fillStyle = "rgba(0,255,255,0.35)";
      ctx.fillRect(bestGhost[i].x, bestGhost[i].y, 30, 30);
    }
  }

  // PLAYER
  ctx.fillStyle = "#4CAF50";
  ctx.fillRect(player.x, player.y, 30, 30);

  // LEVEL
  ctx.fillStyle = "#888";
  level.platforms.forEach(p => ctx.fillRect(p.x, p.y, p.w, p.h));

  ctx.fillStyle = "#AAA";
  level.moving.forEach(p => ctx.fillRect(p.x, p.y, p.w, p.h));

  ctx.fillStyle = "red";
  level.spikes.forEach(s => ctx.fillRect(s.x, s.y, s.w, s.h));

  ctx.fillStyle = "gold";
  ctx.fillRect(level.goal.x, level.goal.y, level.goal.w, level.goal.h);

  // UI
  ctx.fillStyle = "#fff";
  ctx.font = "16px monospace";
  const t = ((performance.now() - startTime) / 1000).toFixed(2);
  ctx.fillText(`Time: ${t}s`, 10, 20);
  if (bestTime) ctx.fillText(`Best: ${bestTime}s`, 10, 40);
  ctx.fillText(`Deaths: ${deaths}`, 10, 60);

  ctx.restore();
}

function loop() {
  update();
  draw();
  requestAnimationFrame(loop);
}

loop();
</script>

</body>
</html>
