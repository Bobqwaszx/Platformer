<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<title>Hard Platformer</title>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<style>
body {
  margin: 0;
  background: black;
  display: flex;
  justify-content: center;
  align-items: center;
  height: 100vh;
}
canvas {
  background: #111;
  border: 2px solid #555;
}
</style>
</head>
<body>

<canvas id="game" width="800" height="400"></canvas>

<script>
/* ================= CORE ================= */
const canvas = document.getElementById("game");
const ctx = canvas.getContext("2d");

const gravity = 0.7;
const jumpForce = -14;
const friction = 0.85;
const keys = {};

const TOTAL_LEVELS = 10;
const CHECKPOINT_INTERVAL = 5;
const HEATMAP_COLS = 80;
const HEATMAP_ROWS = 40;

const SAVE_KEY = "hard_platformer_save";
const LEADERBOARD_KEY = "hard_platformer_leaderboard";

/* ================= STATE ================= */
let currentLevel = 0;
let checkpointLevel = 0;
let levelsCompleted = 0;
let deaths = 0;

/* ================= TIMER ================= */
let startTime; // start after first draw
function getTime() { return performance.now() - startTime; }
function formatTime(ms) {
  if (isNaN(ms)) ms = 0;
  const s = Math.floor(ms / 1000);
  const m = Math.floor(s / 60);
  return `${m}:${(s % 60).toString().padStart(2,"0")}`;
}

/* ================= HEATMAP ================= */
const heatmap = Array.from({length: HEATMAP_COLS}, () =>
  Array.from({length: HEATMAP_ROWS}, () => 0)
);

/* ================= PLAYER ================= */
const player = {
  x: 50, y: 300, w: 30, h: 30,
  vx: 0, vy: 0,
  speed: 0.6,
  maxSpeed: 5,
  grounded: false,
  coyote: 0,
  jumpBuffer: 0
};

/* ================= INPUT ================= */
document.addEventListener("keydown", e => keys[e.code] = true);
document.addEventListener("keyup", e => keys[e.code] = false);

/* ================= BIOMES ================= */
const BIOMES = [
  { name: "GRASS", bg: "#112", spike: "red" },
  { name: "ICE", bg: "#0a1a2a", spike: "#7ff" },
  { name: "LAVA", bg: "#2a0a0a", spike: "orange" },
  { name: "VOID", bg: "#000", spike: "magenta" }
];

/* ================= LEVELS ================= */
const levels = [
  { biome:0, platforms:[{x:0,y:360,w:800,h:40},{x:120,y:300,w:80,h:20},{x:260,y:260,w:80,h:20},{x:400,y:220,w:80,h:20}], moving:[], spikes:[{x:0,y:380,w:800,h:20}], goal:{x:740,y:180,w:40,h:40} },
  { biome:0, platforms:[{x:0,y:360,w:800,h:40},{x:150,y:300,w:70,h:20},{x:280,y:260,w:70,h:20},{x:420,y:220,w:70,h:20}], moving:[{x:250,y:200,w:100,h:20,dx:1,range:100,startX:250}], spikes:[{x:0,y:380,w:800,h:20}], goal:{x:740,y:180,w:40,h:40} },
  { biome:1, platforms:[{x:0,y:360,w:800,h:40},{x:120,y:280,w:80,h:20},{x:260,y:240,w:80,h:20},{x:400,y:200,w:80,h:20}], moving:[{x:200,y:220,w:120,h:20,dx:1.5,range:150,startX:200}], spikes:[{x:0,y:380,w:800,h:20},{x:0,y:0,w:20,h:160}], goal:{x:740,y:150,w:40,h:40} },
  { biome:1, platforms:[{x:0,y:360,w:800,h:40},{x:150,y:300,w:80,h:20},{x:300,y:260,w:80,h:20},{x:450,y:220,w:80,h:20}], moving:[{x:250,y:200,w:120,h:20,dx:2,range:160,startX:250}], spikes:[{x:0,y:380,w:800,h:20},{x:0,y:0,w:20,h:160},{x:780,y:160,w:20,h:200}], goal:{x:740,y:120,w:40,h:40} },
  { biome:2, platforms:[{x:0,y:360,w:800,h:40},{x:130,y:280,w:60,h:20},{x:260,y:240,w:60,h:20},{x:390,y:200,w:60,h:20},{x:520,y:160,w:60,h:20}], moving:[{x:200,y:220,w:120,h:20,dx:2,range:160,startX:200}], spikes:[{x:0,y:380,w:800,h:20},{x:0,y:0,w:20,h:160},{x:780,y:160,w:20,h:200}], goal:{x:740,y:100,w:40,h:40} },
  { biome:1, platforms:[{x:0,y:360,w:800,h:40},{x:140,y:280,w:60,h:20},{x:300,y:240,w:60,h:20},{x:460,y:200,w:60,h:20}], moving:[{x:250,y:210,w:120,h:20,dx:2.5,range:180,startX:250}], spikes:[{x:0,y:380,w:800,h:20},{x:0,y:0,w:20,h:160},{x:780,y:160,w:20,h:200}], goal:{x:740,y:90,w:40,h:40} },
  { biome:2, platforms:[{x:0,y:360,w:800,h:40},{x:120,y:300,w:60,h:20},{x:260,y:250,w:60,h:20},{x:400,y:200,w:60,h:20},{x:540,y:160,w:60,h:20}], moving:[{x:200,y:220,w:120,h:20,dx:3,range:180,startX:200}], spikes:[{x:0,y:380,w:800,h:20},{x:0,y:0,w:20,h:160},{x:780,y:160,w:20,h:200}], goal:{x:740,y:80,w:40,h:40} },
  { biome:3, platforms:[{x:0,y:360,w:800,h:40},{x:150,y:300,w:60,h:20},{x:300,y:260,w:60,h:20},{x:450,y:200,w:60,h:20}], moving:[{x:200,y:210,w:120,h:20,dx:3.5,range:200,startX:200}], spikes:[{x:0,y:380,w:800,h:20},{x:0,y:0,w:20,h:160},{x:780,y:160,w:20,h:200}], goal:{x:740,y:70,w:40,h:40} },
  { biome:3, platforms:[{x:0,y:360,w:800,h:40},{x:130,y:280,w:50,h:20},{x:260,y:240,w:50,h:20},{x:390,y:200,w:50,h:20},{x:520,y:160,w:50,h:20}], moving:[{x:200,y:220,w:120,h:20,dx:4,range:200,startX:200}], spikes:[{x:0,y:380,w:800,h:20},{x:0,y:0,w:20,h:160},{x:780,y:160,w:20,h:200}], goal:{x:740,y:60,w:40,h:40} },
  { biome:3, platforms:[{x:0,y:360,w:800,h:40},{x:120,y:300,w:50,h:20},{x:260,y:250,w:50,h:20},{x:400,y:200,w:50,h:20},{x:540,y:150,w:50,h:20}], moving:[{x:200,y:210,w:120,h:20,dx:4.5,range:220,startX:200}], spikes:[{x:0,y:380,w:800,h:20},{x:0,y:0,w:20,h:160},{x:780,y:160,w:20,h:200}], goal:{x:740,y:50,w:40,h:40} }
];

/* ================= UTILS ================= */
function rect(a,b){
  return a.x < b.x+b.w && a.x+a.w > b.x &&
         a.y < b.y+b.h && a.y+a.h > b.y;
}
function respawn(){
  player.x = 50;
  player.y = 300;
  player.vx = player.vy = 0;
}

/* ================= SAVE / LOAD ================= */
function saveGame(){
  localStorage.setItem(SAVE_KEY, JSON.stringify({
    currentLevel, checkpointLevel, levelsCompleted, deaths, runTime: getTime(), heatmap
  }));
}
function loadGame(){
  const raw = localStorage.getItem(SAVE_KEY);
  if(!raw) return false;
  try{
    const d = JSON.parse(raw);
    currentLevel = d.currentLevel ?? 0;
    checkpointLevel = d.checkpointLevel ?? 0;
    levelsCompleted = d.levelsCompleted ?? 0;
    deaths = d.deaths ?? 0;
    return true;
  }catch{return false;}
}

/* ================= LEADERBOARD ================= */
function loadLeaderboard(){
  return JSON.parse(localStorage.getItem(LEADERBOARD_KEY) || "[]");
}
function saveLeaderboard(lb){
  localStorage.setItem(LEADERBOARD_KEY, JSON.stringify(lb));
}
function addLeaderboardEntry(name, time){
  const lb = loadLeaderboard();
  lb.push({name,time});
  lb.sort((a,b)=>a.time-b.time);
  saveLeaderboard(lb.slice(0,5));
}

/* ================= UPDATE ================= */
function update(){
  const level = levels[currentLevel];

  // Movement
  if (keys.KeyA || keys.ArrowLeft) player.vx -= player.speed;
  if (keys.KeyD || keys.ArrowRight) player.vx += player.speed;
  if (keys.KeyW || keys.ArrowUp || keys.Space) player.jumpBuffer = 6;
  else player.jumpBuffer--;

  player.vx *= friction;
  player.vx = Math.max(-player.maxSpeed, Math.min(player.maxSpeed, player.vx));
  player.vy += gravity;
  player.x += player.vx;
  player.y += player.vy;

  player.grounded = false;

  // Platforms collision
  [...level.platforms,...level.moving].forEach(p=>{
    if(rect(player,p)){
      const prevY = player.y - player.vy;
      if(prevY+player.h <= p.y){
        player.y = p.y - player.h;
        player.vy = 0;
        player.grounded = true;
        player.coyote = 6;
        if(p.dx) player.x += p.dx;
      }
    }
  });

  if(!player.grounded) player.coyote--;

  // Jump
  if(player.jumpBuffer>0 && player.coyote>0){
    player.vy = jumpForce;
    player.jumpBuffer = 0;
  }

  // Spikes
  level.spikes.forEach(s=>{
    if(rect(player,s)){
      deaths++;
      heatmap[Math.floor(player.x/10)][Math.floor(player.y/10)]++;
      currentLevel = checkpointLevel;
      respawn();
      saveGame();
    }
  });

  // Goal
  if(rect(player,level.goal)){
    currentLevel++;
    levelsCompleted++;
    if(currentLevel % CHECKPOINT_INTERVAL === 0) checkpointLevel = currentLevel;
    if(currentLevel >= levels.length){
      const runTime = getTime();
      const name = prompt(`YOU BEAT THE GAME! Time: ${formatTime(runTime)}\nEnter name:`, "PLAYER");
      if(name) addLeaderboardEntry(name.slice(0,12), runTime);
      currentLevel = checkpointLevel = levelsCompleted = deaths = 0;
      respawn();
      saveGame();
      return;
    }
    respawn();
    saveGame();
  }

  // Moving platforms
  level.moving.forEach(p=>{
    p.x += p.dx;
    if(Math.abs(p.x - p.startX) > p.range) p.dx*=-1;
  });
}

/* ================= DRAW ================= */
function draw(){
  const level = levels[currentLevel];

  // Background
  ctx.fillStyle = BIOMES[level.biome].bg;
  ctx.fillRect(0,0,800,400);

  // Heatmap
  for(let x=0;x<HEATMAP_COLS;x++)
    for(let y=0;y<HEATMAP_ROWS;y++)
      if(heatmap[x][y]>0){
        ctx.fillStyle=`rgba(255,0,0,${Math.min(heatmap[x][y]/10,0.4)})`;
        ctx.fillRect(x*10,y*10,10,10);
      }

  // Platforms
  ctx.fillStyle="#888";
  level.platforms.forEach(p=>ctx.fillRect(p.x,p.y,p.w,p.h));
  ctx.fillStyle="#aaa";
  level.moving.forEach(p=>ctx.fillRect(p.x,p.y,p.w,p.h));

  // Spikes
  ctx.fillStyle = BIOMES[level.biome].spike;
  level.spikes.forEach(s=>ctx.fillRect(s.x,s.y,s.w,s.h));

  // Goal
  ctx.fillStyle="gold";
  ctx.fillRect(level.goal.x,level.goal.y,level.goal.w,level.goal.h);

  // Player
  ctx.fillStyle="#4CAF50";
  ctx.fillRect(player.x,player.y,player.w,player.h);

  // UI
  ctx.fillStyle="#fff";
  ctx.font="14px monospace";
  ctx.fillText(`Level: ${currentLevel+1}/${levels.length}`,10,18);
  ctx.fillText(`Checkpoint: ${checkpointLevel+1}`,10,34);
  ctx.fillText(`Deaths: ${deaths}`,10,50);
  ctx.fillText(`Completed: ${levelsCompleted}`,10,66);
  ctx.fillText(`Time: ${formatTime(getTime())}`,10,82);

  // Leaderboard
  const lb = loadLeaderboard();
  ctx.fillText("ðŸ† Fastest Runs",520,20);
  lb.forEach((e,i)=>ctx.fillText(`${i+1}. ${e.name} â€” ${formatTime(e.time)}`,520,40+i*18));
}

/* ================= INITIALIZE & LOOP ================= */
loadGame();
respawn();                     // Ensure player starts in position
startTime = performance.now();  // Start timer BEFORE first draw
draw();                         // Draw first frame immediately

function loop(){
  update();
  draw();
  requestAnimationFrame(loop);
}
loop();
</script>

</body>
</html>
